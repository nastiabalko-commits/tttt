<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <title>Matrix Chat</title>

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Alpine.js -->
  <script src="https://unpkg.com/alpinejs" defer></script>

  <!-- Підключення JS компонентів -->
  <script src="./login/login.js"></script>
  <script src="./sidebar/sidebar.js"></script>

  <!-- Підключення стилів компонентів -->
  <link rel="stylesheet" href="./login/login.css">
  <link rel="stylesheet" href="./sidebar/sidebar.css">

  <style>
    .chat-container {
      min-height: 80vh;
    }
    .sidebar {
      min-width: 250px;
    }
    .chat-area {
      flex-grow: 1;
    }
    .message {
      background: #f3f4f6;
      padding: 6px 10px;
      border-radius: 6px;
      margin-bottom: 6px;
    }
    .message strong {
      color: #2563eb;
    }
  </style>
</head>

<body class="bg-gray-100 flex items-center justify-center p-4">
  <div x-data="chatApp()" class="chat-container bg-white rounded-lg shadow-lg flex w-full max-w-5xl">

    <!-- Контейнер для сайдбару -->
    <div id="sidebar-container"></div>

    <!-- Контейнер для чату -->
    <div class="chat-area p-4 flex flex-col space-y-4">

      <!-- Контейнер для логіну -->
      <div id="login-container"></div>

      <!-- Контейнер для повідомлень -->
      <template x-if="accessToken && roomId">
        <div class="messages flex flex-col space-y-2 overflow-y-auto max-h-[60vh]">
          <template x-for="msg in messages" :key="msg.sender + msg.body">
            <div class="message">
              <strong x-text="msg.sender"></strong>:
              <span x-text="msg.body"></span>
            </div>
          </template>
        </div>
      </template>

    </div>
  </div>

  <script>
    // Завантаження HTML-шаблонів компонентів
    document.addEventListener('DOMContentLoaded', () => {
      // login.html
      fetch('./login/login.html')
        .then(r => r.text())
        .then(html => document.getElementById('login-container').innerHTML = html)
        .catch(err => console.error('Error loading login:', err));

      // sidebar.html
      fetch('./sidebar/sidebar.html')
        .then(r => r.text())
        .then(html => document.getElementById('sidebar-container').innerHTML = html)
        .catch(err => console.error('Error loading sidebar:', err));
    });

    // ---------- ФУНКЦІЇ ----------

    // Логін користувача
    async function login() {
      try {
        const res = await fetch('https://matrix.org/_matrix/client/r0/login', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            type: 'm.login.password',
            user: this.username,
            password: this.password
          })
        });

        const data = await res.json();

        if (data.access_token) {
          this.accessToken = data.access_token;
          this.userId = data.user_id;
          await this.fetchRoomsWithNames();
          this.fetchMessages?.();

          setInterval(() => {
            this.fetchRoomsWithNames();
            this.fetchMessages?.();
          }, 5000);
        } else {
          this.error = 'Login failed: ' + (data.error || 'Unknown error');
        }
      } catch (e) {
        console.error('Login error:', e);
        this.error = 'Error during login: ' + e.message;
      }
    }

    // Створення кімнати
    async function createRoom() {
      if (!this.newRoomName.trim()) return;
      try {
        const res = await fetch('https://matrix.org/_matrix/client/r0/createRoom', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${this.accessToken}`
          },
          body: JSON.stringify({
            preset: 'private_chat',
            name: this.newRoomName.trim(),
            invite: this.inviteUser ? [this.inviteUser.trim()] : []
          })
        });

        const data = await res.json();

        if (data.room_id) {
          this.newRoomId = data.room_id;
          this.roomId = data.room_id;
          this.messages = [];
          this.lastSyncToken = '';
          await this.fetchRoomsWithNames();
          this.fetchMessages?.();
          alert(`Room "${this.newRoomName}" created successfully!`);
        } else {
          alert('Create room failed: ' + (data.error || 'Unknown error'));
        }
      } catch (e) {
        console.error('Create room error:', e);
        alert('Create room error: ' + e.message);
      }
    }

    // Отримання списку кімнат
    async function fetchRoomsWithNames() {
      if (!this.accessToken) return;
      try {
        const res = await fetch('https://matrix.org/_matrix/client/r0/joined_rooms', {
          headers: { 'Authorization': `Bearer ${this.accessToken}` }
        });

        const data = await res.json();

        if (data.joined_rooms) {
          const roomPromises = data.joined_rooms.map(async (roomId) => {
            const nameRes = await fetch(
              `https://matrix.org/_matrix/client/r0/rooms/${encodeURIComponent(roomId)}/state/m.room.name`,
              { headers: { 'Authorization': `Bearer ${this.accessToken}` } }
            );
            const nameData = await nameRes.json();
            return {
              roomId,
              name: nameData?.name || roomId
            };
          });

          this.rooms = (await Promise.all(roomPromises))
            .sort((a, b) => a.roomId.localeCompare(b.roomId));

          if (this.rooms.length > 0 && !this.roomId) {
            this.roomId = this.rooms[0].roomId;
            this.fetchMessages?.();
          }
        }
      } catch (e) {
        console.error('Fetch rooms error:', e);
      }
    }

    // Завантаження повідомлень кімнати
    async function fetchMessages() {
      if (!this.roomId) return;
      try {
        const res = await fetch(
          `https://matrix.org/_matrix/client/r0/rooms/${encodeURIComponent(this.roomId)}/messages?dir=b`,
          { headers: { 'Authorization': `Bearer ${this.accessToken}` } }
        );

        const data = await res.json();

        if (data.chunk) {
          this.messages = data.chunk.map(msg => ({
            sender: msg.sender,
            body: msg.content?.body || ''
          }));
        }
      } catch (e) {
        console.error('Fetch messages error:', e);
      }
    }

    // Перемикання кімнат
    async function switchRoom(roomId) {
      this.roomId = roomId;
      this.messages = [];
      this.lastSyncToken = '';
      await this.fetchMessages?.();
    }

    // ---------- СТАН ДОДАТКА ----------
    function chatApp() {
      return {
        username: '',
        password: '',
        accessToken: '',
        userId: '',
        roomId: '',
        joinRoomId: '',
        newRoomName: '',
        newRoomId: '',
        rooms: [],
        messages: [],
        newMessage: '',
        inviteUser: '',
        error: '',
        lastSyncToken: '',
        login,
        createRoom,
        fetchRoomsWithNames,
        fetchMessages,
        switchRoom
      }
    }
  </script>
</body>
</html>
